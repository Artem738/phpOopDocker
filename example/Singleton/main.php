<?php

class Singleton
{
    private static $instance;

    private function __construct()
    {
        // Приватный конструктор предотвращает создание объекта через new
    }

    public static function getInstance(): Singleton
    {
        if (null === self::$instance) {
            self::$instance = new self();
        }

        return self::$instance;
    }
}

$instance1 = Singleton::getInstance();
$instance2 = Singleton::getInstance();

if ($instance1 === $instance2) {
    echo "Оба экземпляра являются одним и тем же объектом".PHP_EOL;
}

//Singleton часто критикуют и считают антипаттерном по нескольким причинам:
//
//Глобальное состояние: Singleton создает глобальный экземпляр, что делает неявными зависимости между компонентами.
//
//Тестирование: Из-за глобального состояния и неявных зависимостей, Singleton делает код сложнее для тестирования.
//
//Нарушение принципа единой ответственности: Класс в Singleton-паттерне занимается как своей основной функциональностью, так и контролем за своим же экземпляром.
//
//Нерасширяемость: Так как конструктор в Singleton приватный, класс невозможно унаследовать и расширить.
//
//Потокобезопасность: В многопоточной среде нужно аккуратно обрабатывать создание экземпляра, что может привести к проблемам производительности.
//
//Процедурный стиль: Как вы правильно заметили, стиль похож на процедурное программирование, где функции и данные не так сильно связаны, как это было бы в полноценном объектно-ориентированном стиле.
//
//Вместо использования Singleton, часто рекомендуют применение Dependency Injection для передачи зависимостей, что делает код более гибким и тестируемым.

//В целом, паттерн Singleton может быть полезным в очень ограниченных случаях, но его недостатки часто перевешивают возможные преимущества.